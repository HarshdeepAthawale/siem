import { BaseDetector } from './baseDetector.js';
import { Event } from '../database/models/Event.js';
import { Alert } from '../database/models/Alert.js';
import { config } from '../config/index.js';
import { logger } from '../utils/logger.js';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class MalwareDetector extends BaseDetector {
  constructor() {
    super('MalwareDetector');
    this.enabled = config.detection.malwareDetectionEnabled;
    this.threshold = config.detection.suspiciousProcessThreshold;
    this.suspiciousPatterns = this.loadSuspiciousPatterns();
  }

  loadSuspiciousPatterns() {
    const defaultPatterns = [
      // PowerShell encoded commands
      { pattern: /powershell.*-enc/i, description: 'PowerShell encoded command' },
      { pattern: /powershell.*-e\s/i, description: 'PowerShell encoded command' },
      { pattern: /powershell.*-encodedcommand/i, description: 'PowerShell encoded command' },
      // Suspicious executables
      { pattern: /wscript\.exe/i, description: 'Windows Script Host execution' },
      { pattern: /cscript\.exe/i, description: 'Command-line script execution' },
      { pattern: /rundll32\.exe/i, description: 'DLL execution via rundll32' },
      { pattern: /regsvr32\.exe/i, description: 'DLL registration' },
      { pattern: /mshta\.exe/i, description: 'HTML Application execution' },
      // Temp directory execution
      { pattern: /temp.*\.exe/i, description: 'Executable from temp directory' },
      { pattern: /appdata.*local.*temp.*\.exe/i, description: 'Executable from user temp' },
      { pattern: /%temp%.*\.exe/i, description: 'Executable from temp environment variable' },
      // Suspicious file extensions
      { pattern: /\.scr$/i, description: 'Screen saver file execution' },
      { pattern: /\.vbs$/i, description: 'VBScript execution' },
      { pattern: /\.js$/i, description: 'JavaScript execution' },
      { pattern: /\.jse$/i, description: 'JScript Encoded execution' },
      // Process injection patterns
      { pattern: /CreateRemoteThread/i, description: 'Process injection technique' },
      { pattern: /WriteProcessMemory/i, description: 'Process memory manipulation' },
      // Network patterns
      { pattern: /download.*\.exe/i, description: 'Downloaded executable' },
      { pattern: /http.*\.exe/i, description: 'Executable from HTTP' },
    ];

    // Try to load from file if exists
    const patternsFile = path.join(__dirname, '../../rules/malwarePatterns.json');
    try {
      if (fs.existsSync(patternsFile)) {
        const fileContent = fs.readFileSync(patternsFile, 'utf8');
        const customPatterns = JSON.parse(fileContent);
        return [...defaultPatterns, ...customPatterns];
      }
    } catch (error) {
      logger.warn('Could not load malware patterns file, using defaults');
    }

    return defaultPatterns;
  }

  async detect() {
    if (!this.enabled) {
      return 0;
    }

    try {
      const windowStart = new Date(Date.now() - 60 * 60 * 1000); // Last hour

      // Detect suspicious process creation (Event ID 4688)
      const pipeline = [
        {
          $match: {
            event_id: 4688,
            timestamp: { $gte: windowStart },
            $or: [
              { process_name: { $exists: true, $ne: null } },
              { command_line: { $exists: true, $ne: null } },
            ],
          },
        },
        {
          $addFields: {
            checkString: {
              $concat: [
                { $ifNull: ['$process_name', ''] },
                ' ',
                { $ifNull: ['$command_line', ''] },
              ],
            },
          },
        },
        {
          $group: {
            _id: {
              source_ip: '$source_ip',
              process_name: '$process_name',
            },
            count: { $sum: 1 },
            first_seen: { $min: '$timestamp' },
            last_seen: { $max: '$timestamp' },
            eventIds: { $push: '$_id' },
            commandLines: { $addToSet: '$command_line' },
            usernames: { $addToSet: '$username' },
          },
        },
        {
          $match: {
            count: { $gte: this.threshold },
          },
        },
      ];

      const results = await Event.aggregate(pipeline);
      const alerts = [];

      for (const result of results) {
        const sourceIp = result._id.source_ip;
        const processName = result._id.process_name || 'unknown';

        // Check if process matches suspicious patterns
        const checkString = `${processName} ${result.commandLines.join(' ')}`.toLowerCase();
        const matchedPatterns = this.suspiciousPatterns.filter(p => p.pattern.test(checkString));

        if (matchedPatterns.length > 0) {
          const existingAlert = await Alert.findOne({
            alert_type: 'malware_detection',
            source_ip: sourceIp,
            created_at: { $gte: windowStart },
            false_positive: false,
          });

          if (!existingAlert) {
            const descriptions = matchedPatterns.map(p => p.description).join(', ');
            alerts.push({
              alert_type: 'malware_detection',
              source_ip: sourceIp,
              severity: 'critical',
              count: result.count,
              first_seen: result.first_seen,
              last_seen: result.last_seen,
              description: `Suspicious process detected: ${processName} executed ${result.count} times from ${sourceIp}. Indicators: ${descriptions}. Users: ${result.usernames.filter(Boolean).join(', ') || 'unknown'}`,
              created_at: new Date(),
              correlated_events: result.eventIds || [],
              attack_chain: ['process_creation', 'suspicious_process', 'potential_malware'],
              confidence_score: matchedPatterns.length >= 2 ? 85 : 70,
              tags: ['malware', 'suspicious_process', 'windows', 'process_creation'],
            });
          }
        }
      }

      // Save all alerts
      for (const alertData of alerts) {
        const alert = new Alert(alertData);
        await alert.save();
        logger.warn(`Malware Detection Alert Created: ${alertData.source_ip} - ${alertData.description}`);
      }

      return alerts.length;
    } catch (error) {
      logger.error('Error in malware detection:', error);
      throw error;
    }
  }
}

